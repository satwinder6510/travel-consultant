<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Cruise Consultant v2</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .animate-bounce-dot { animation: bounce 1s infinite; }
    .animate-bounce-dot:nth-child(2) { animation-delay: 0.1s; }
    .animate-bounce-dot:nth-child(3) { animation-delay: 0.2s; }
  </style>
</head>
<body class="bg-gradient-to-b from-blue-50 to-white min-h-screen">
  <div id="app" class="flex flex-col h-screen"></div>

  <script>
    // ========================================================================
    // CRUISE DATA - Loaded from JSON
    // ========================================================================
    let CRUISES = [];
    let SHIPS = [];
    let OPERATORS = [];
    let dataLoaded = false;

    async function loadCruiseData() {
      try {
        const [cruisesRes, shipsRes, operatorsRes] = await Promise.all([
          fetch('https://pub-484ab07ee6e74f0197c2acd5c8016f86.r2.dev/cruise-data-full.json'),
          fetch('cruise-data-ships-all.json'),
          fetch('cruise-data-operators.json')
        ]);
        CRUISES = await cruisesRes.json();
        SHIPS = await shipsRes.json();
        OPERATORS = await operatorsRes.json();
        dataLoaded = true;
        // Filter to future cruises with valid prices only
        const today = new Date().toISOString().split('T')[0];
        filteredCruises = CRUISES.filter(c =>
          c.start && c.start >= today &&
          c.price && parseFloat(c.price) > 0
        );
        displayCruises = [...filteredCruises];
        console.log(`Loaded ${CRUISES.length} cruises, ${SHIPS.length} ships, ${OPERATORS.length} operators`);
        buildSystemPrompt();
        render();
      } catch (error) {
        console.error('Failed to load cruise data:', error);
        document.getElementById('app').innerHTML = `
          <div class="flex items-center justify-center h-screen">
            <div class="text-red-600 text-center">
              <p class="text-xl font-bold">Failed to load cruise data</p>
              <p class="text-sm mt-2">Check console for details</p>
            </div>
          </div>`;
      }
    }

    let SYSTEM_PROMPT = '';

    function buildSystemPrompt() {
      // Limit cruises for prompt size
      const cruiseList = CRUISES.slice(0, 100).map(c =>
        `‚Ä¢ ${c.ref}: "${c.name}" by ${c.operator} | ${c.region} | ${c.nights}N | ${c.start} | ${c.from}‚Üí${c.to} | ${c.rating} | ¬£${c.price}`
      ).join('\n');

      // Sample ships (mix of river and ocean)
      const sampleShips = SHIPS.slice(0, 50);
      const shipList = sampleShips.map(s =>
        `‚Ä¢ ${s.name}: ${s.operator} | ${s.capacity || '?'} guests | Built ${s.year || '?'} | ${s.type || ''}`
      ).join('\n');

      SYSTEM_PROMPT = `You are an expert cruise consultant for BOTH river and ocean cruises. Always recommend SPECIFIC cruises from the data below with actual prices and dates.

CRUISE INVENTORY (${CRUISES.length} total, showing sample):
${cruiseList}

SHIPS (${sampleShips.length} ships):
${shipList}

QUERY HANDLING:

1. DESTINATIONS/RIVERS - Match to region field:
   - Rhine: Castles, vineyards, Cologne, Amsterdam, Basel
   - Danube: Vienna, Budapest, Passau, cultural capitals
   - Douro: Portugal wine country, Porto, terraced vineyards
   - Rh√¥ne: Provence, Lyon, French cuisine, lavender

2. BEST TIME TO CRUISE - Match to start dates:
   - Spring (Apr-May): Tulips, mild weather
   - Summer (Jun-Aug): Peak season, family-friendly
   - Christmas Markets (Nov-Dec): Festive, magical
   - Shoulder (Sep-Oct): Wine harvest, fewer crowds

3. OPERATORS - Match to operator field:
   - A-ROSA: German, Premium, all-inclusive drinks
   - Viking: Scandinavian design, cultural focus, Premium
   - AmaWaterways: American, Luxury, top dining
   - Scenic: Australian, Luxury, all-inclusive
   - UNIWORLD: Boutique, Ultra Luxury, art-themed ships

4. LUXURY LEVELS - Match to rating field:
   - Premium (¬£950-1500): Quality, good value
   - Luxury (¬£2500-4000): All-inclusive, fine dining
   - Ultra Luxury (¬£4000+): Butler service, exclusive

5. BUDGET QUERIES - Sort/filter by price field:
   - "Budget" or "value": Show lowest prices first
   - "Luxury": Filter rating=Luxury or Ultra Luxury
   - Compare cabin types: inside‚Üíoutside‚Üíbalcony‚Üísuite

6. EXPERIENCES - Match cruise names and regions:
   - Wine: Douro, Moselle, Rhine vineyards
   - Christmas markets: Nov-Dec departures on Danube/Rhine
   - Cultural: Danube capitals, Viking itineraries
   - Scenic: Rhine castles, Douro valleys

7. PRACTICAL CONCERNS - Use your knowledge:
   - Accessibility: River ships have limited mobility access
   - Solo travel: Single supplements vary by operator
   - Family: Check ship policies, summer dates best
   - First-timers: Recommend Rhine or Danube, 7 nights

ALWAYS: Quote specific cruise ref, ship name, exact dates, and real prices. Never invent cruises.`;
    }

    // ========================================================================
    // APP STATE
    // ========================================================================
    let currentFilters = { query: '' };
    let filteredCruises = [];    // Full filtered list (for real count)
    let displayCruises = [];     // Cached results for cards (synced with prompt)
    let userTurns = 0;           // Track conversation depth
    let accumulatedFilters = new Set(); // Persists across conversation

    let messages = [
      { role: 'assistant', content: `Hello! I'm your cruise consultant with access to thousands of river and ocean cruises.

**What kind of cruise are you looking for?** Just tell me in your own words - destination, time of year, budget, or anything else that matters to you.` }
    ];
    let apiKey = localStorage.getItem('anthropic_api_key') || '';
    let isLoading = false;

    // Multi-select filter state
    let selectedFilters = new Set();

    // Filter categories
    const FILTER_OPTIONS = {
      type: ['River', 'Ocean'],
      region: ['Caribbean', 'Mediterranean', 'Alaska', 'Danube', 'Rhine', 'Northern Europe'],
      when: ['Spring', 'Summer', 'Fall', 'Winter', 'Christmas'],
      duration: ['3-5 nights', '7 nights', '10-14 nights'],
      budget: ['Under ¬£1000', '¬£1000-2000', '¬£2000+', 'Luxury']
    };

    function toggleFilter(filter) {
      if (selectedFilters.has(filter)) {
        selectedFilters.delete(filter);
      } else {
        selectedFilters.add(filter);
      }
      // Update filtered cruises based on current selections
      updateFilteredCruises();
      render();
    }

    function updateFilteredCruises() {
      // Combine accumulated + currently selected for live preview
      const allFilters = new Set([...accumulatedFilters, ...selectedFilters]);

      if (allFilters.size === 0) {
        filteredCruises = CRUISES.filter(c =>
          c.start && c.start >= TODAY &&
          c.price && parseFloat(c.price) > 0
        );
        return;
      }
      const filters = Array.from(allFilters).join(' ');
      filteredCruises = filterCruises(filters);
      console.log('Live filter:', filters, '‚Üí', filteredCruises.length, 'results');
    }

    function applyFilters() {
      if (selectedFilters.size === 0) return;

      // Add new selections to accumulated filters
      selectedFilters.forEach(f => accumulatedFilters.add(f));

      // Use ALL accumulated filters for the search
      const allFilters = Array.from(accumulatedFilters).join(' ');

      // But only show the NEW selections in the chat message
      const newFilters = Array.from(selectedFilters).join(', ');
      document.getElementById('messageInput').value = newFilters;

      console.log('New filters:', newFilters);
      console.log('All accumulated:', allFilters);

      selectedFilters.clear();
      sendMessage();
    }

    function clearFilters() {
      selectedFilters.clear();
      accumulatedFilters.clear(); // Also clear conversation history filters
      filteredCruises = CRUISES.filter(c =>
        c.start && c.start >= TODAY &&
        c.price && parseFloat(c.price) > 0
      );
      displayCruises = [...filteredCruises];
      render();
    }

    // Get cheapest cruise per operator
    function getCheapestPerOperator(cruises, limit = 5) {
      const byOperator = {};
      for (const c of cruises) {
        const op = c.operator || 'Unknown';
        if (!byOperator[op] || parseFloat(c.price) < parseFloat(byOperator[op].price)) {
          byOperator[op] = c;
        }
      }
      return Object.values(byOperator)
        .sort((a, b) => parseFloat(a.price) - parseFloat(b.price))
        .slice(0, limit);
    }

    // ========================================================================
    // RENDER
    // ========================================================================
    function render() {
      const app = document.getElementById('app');

      if (!dataLoaded) {
        app.innerHTML = `
          <div class="flex items-center justify-center h-screen">
            <div class="text-blue-600 text-center">
              <div class="text-4xl mb-4">üö¢</div>
              <p class="text-xl font-bold">Loading cruise data...</p>
            </div>
          </div>`;
        return;
      }

      app.innerHTML = `
        <!-- Header with progress -->
        <header class="bg-blue-900 text-white p-4 shadow-lg">
          <div class="max-w-4xl mx-auto flex items-center justify-between">
            <div>
              <h1 class="text-2xl font-bold">Cruise Consultant</h1>
              <p class="text-blue-200 text-sm">Find your perfect river or ocean cruise</p>
            </div>
            <div class="text-right">
              <div class="text-2xl font-bold">${filteredCruises.length.toLocaleString()}</div>
              <div class="text-xs text-blue-200">
                ${filteredCruises.length === CRUISES.length ? 'cruises available' :
                  filteredCruises.length > 100 ? 'options remaining' :
                  filteredCruises.length > 10 ? 'getting closer' :
                  filteredCruises.length > 0 ? 'almost there!' : 'no matches'}
              </div>
              <div class="w-24 bg-blue-800 rounded-full h-1 mt-1">
                <div class="bg-blue-300 h-1 rounded-full transition-all duration-500"
                     style="width: ${Math.max(5, 100 - (filteredCruises.length / CRUISES.length * 100))}%"></div>
              </div>
            </div>
          </div>
        </header>

        <!-- Messages -->
        <div class="flex-1 overflow-y-auto p-4">
          <div class="max-w-4xl mx-auto space-y-4">
            ${messages.map(m => `
              <div class="flex ${m.role === 'user' ? 'justify-end' : 'justify-start'}">
                <div class="max-w-[80%] rounded-2xl px-4 py-3 ${
                  m.role === 'user'
                    ? 'bg-blue-600 text-white rounded-br-md'
                    : 'bg-white shadow-md border border-gray-100 rounded-bl-md'
                }">
                  <div class="whitespace-pre-wrap text-sm leading-relaxed">${m.content}</div>
                </div>
              </div>
            `).join('')}
            ${isLoading ? `
              <div class="flex justify-start">
                <div class="bg-white shadow-md rounded-2xl px-4 py-3">
                  <div class="flex gap-1 text-gray-400">
                    <span class="animate-bounce-dot">‚óè</span>
                    <span class="animate-bounce-dot">‚óè</span>
                    <span class="animate-bounce-dot">‚óè</span>
                  </div>
                </div>
              </div>
            ` : ''}
          </div>
        </div>

        <!-- Cruise Cards - Cheapest per cruise line after 2+ interactions -->
        ${userTurns >= 2 && displayCruises.length > 0 ? `
        <div class="border-t bg-gradient-to-b from-green-50 to-white p-3">
          <div class="max-w-4xl mx-auto">
            <div class="flex justify-between items-center mb-2">
              <span class="text-sm font-semibold text-green-800">üí∞ Best price per cruise line (${displayCruises.length.toLocaleString()} matches)</span>
            </div>
            <div class="flex gap-2 overflow-x-auto pb-2">
              ${getCheapestPerOperator(displayCruises, 5).map(c => `
                <div class="flex-shrink-0 w-56 bg-white rounded-lg p-3 shadow-sm border text-xs hover:shadow-md transition-shadow cursor-pointer">
                  <div class="font-bold text-blue-800 truncate">${c.operator}</div>
                  <div class="text-gray-700 truncate">${c.ship}</div>
                  <div class="text-gray-500">${c.region} &bull; ${c.nights}N</div>
                  <div class="text-blue-600 font-medium">‚õµ ${c.start ? new Date(c.start).toLocaleDateString('en-GB', {day: 'numeric', month: 'short', year: 'numeric'}) : 'TBC'}</div>
                  <div class="flex justify-between items-center mt-1">
                    <span class="text-green-700 font-bold">¬£${parseFloat(c.price).toLocaleString()}</span>
                    <span class="px-2 py-0.5 rounded text-xs ${c.type === 'ocean' ? 'bg-blue-100 text-blue-700' : 'bg-green-100 text-green-700'}">${c.type}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        </div>
        ` : ''}

        <!-- Input -->
        <div class="border-t bg-white p-4">
          <div class="max-w-4xl mx-auto flex gap-3">
            <input type="text" id="messageInput" placeholder="Tell me about your dream cruise..."
              class="flex-1 px-4 py-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500"
              onkeypress="if(event.key==='Enter')sendMessage()" ${isLoading ? 'disabled' : ''}>
            <button onclick="sendMessage()" ${isLoading ? 'disabled' : ''}
              class="px-6 py-3 bg-blue-600 text-white rounded-full font-medium hover:bg-blue-700 disabled:opacity-50">
              Send
            </button>
          </div>
          <!-- Multi-select filters - only show after first interaction -->
          ${userTurns >= 1 ? `
          <div class="max-w-4xl mx-auto mt-3 space-y-2">
            <p class="text-sm font-medium text-blue-800">üëÜ Click as many as apply to narrow your results:</p>
            <div class="flex flex-wrap gap-1.5">
              ${Object.entries(FILTER_OPTIONS).map(([category, options]) =>
                options.map(opt => `
                  <button onclick="toggleFilter('${opt}')"
                    class="px-3 py-1 text-sm rounded-full transition-all ${
                      selectedFilters.has(opt)
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                    }">
                    ${opt}
                  </button>
                `).join('')
              ).join('')}
            </div>
            ${selectedFilters.size > 0 ? `
              <div class="flex items-center gap-3 mt-2 p-2 bg-green-50 rounded-lg border border-green-200">
                <span class="text-sm font-medium text-green-800">${selectedFilters.size} filter${selectedFilters.size > 1 ? 's' : ''} selected</span>
                <button onclick="applyFilters()"
                  class="px-5 py-2 bg-green-600 text-white text-sm font-bold rounded-full hover:bg-green-700 transition-colors shadow-md">
                  üîç Find Cruises
                </button>
                <button onclick="clearFilters()"
                  class="px-3 py-1.5 text-sm text-gray-500 hover:text-red-600">
                  ‚úï Clear
                </button>
              </div>
            ` : ''}
          </div>
          ` : ''}
        </div>
      `;

      // Scroll to bottom
      const messagesDiv = document.querySelector('.overflow-y-auto');
      if (messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function saveApiKey() {
      apiKey = document.getElementById('apiKeyInput').value;
      localStorage.setItem('anthropic_api_key', apiKey);
      render();
    }

    // ========================================================================
    // SMART FILTERING - Extract criteria from user message
    // ========================================================================
    const TODAY = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

    function filterCruises(userMessage) {
      const msg = userMessage.toLowerCase();
      console.log('Filtering with:', msg);

      // Start with future cruises only, with valid prices
      let filtered = CRUISES.filter(c =>
        c.start && c.start >= TODAY &&
        c.price && parseFloat(c.price) > 0
      );
      console.log('After date/price filter:', filtered.length);

      // Cruise type filter (river vs ocean)
      const oceanKeywords = [
        'ocean', 'caribbean', 'mediterranean', 'alaska', 'bahamas', 'hawaii', 'cruise ship',
        'ncl', 'norwegian', 'royal caribbean', 'msc', 'carnival', 'celebrity', 'princess',
        'holland america', 'cunard', 'p&o', 'costa', 'disney cruise', 'silversea'
      ];
      const riverKeywords = ['river', 'a-rosa', 'viking river', 'amawaterways', 'uniworld', 'avalon'];

      if (riverKeywords.some(k => msg.includes(k))) {
        filtered = filtered.filter(c => c.type === 'river');
        console.log('After river filter:', filtered.length);
      } else if (oceanKeywords.some(k => msg.includes(k))) {
        filtered = filtered.filter(c => c.type === 'ocean');
        console.log('After ocean filter:', filtered.length);
      }

      // Region filters (river + ocean)
      const regions = {
        // River regions
        'danube': 'Danube', 'vienna': 'Danube', 'budapest': 'Danube', 'passau': 'Danube',
        'rhine': 'Rhine', 'cologne': 'Rhine', 'basel': 'Rhine',
        'douro': 'Douro', 'porto': 'Douro',
        'rhone': 'Rhone', 'rh√¥ne': 'Rhone', 'lyon': 'Rhone', 'provence': 'Rhone',
        'seine': 'Seine', 'paris': 'Seine',
        'mekong': 'Mekong', 'vietnam': 'Mekong', 'cambodia': 'Mekong',
        'nile': 'Nile', 'egypt': 'Nile',
        // Ocean regions
        'caribbean': 'Caribbean', 'bahamas': 'Caribbean', 'jamaica': 'Caribbean',
        'mediterranean': 'Mediterranean', 'greek': 'Mediterranean', 'italy': 'Mediterranean', 'spain': 'Mediterranean', 'rome': 'Mediterranean', 'barcelona': 'Mediterranean', 'athens': 'Mediterranean',
        'alaska': 'Alaska',
        'northern europe': 'Northern Europe', 'norway': 'Northern Europe', 'scandinavia': 'Northern Europe', 'fjords': 'Northern Europe',
        'asia': 'Asia', 'japan': 'Asia', 'singapore': 'Asia',
        'pacific': 'Pacific', 'hawaii': 'Pacific',
        'south america': 'South America', 'brazil': 'South America',
        'australia': 'Australia & New Zealand', 'new zealand': 'Australia & New Zealand'
      };
      for (const [keyword, region] of Object.entries(regions)) {
        if (msg.includes(keyword)) {
          filtered = filtered.filter(c =>
            c.region && c.region.toLowerCase().includes(region.toLowerCase())
          );
          console.log('After region filter (' + region + '):', filtered.length);
          break;
        }
      }

      // Budget filters
      const budgetMatch = msg.match(/(?:under|below|max|budget|¬£|¬£)\s*(\d{3,5})/);
      if (budgetMatch) {
        const maxPrice = parseInt(budgetMatch[1]);
        filtered = filtered.filter(c => parseFloat(c.price) <= maxPrice);
      }
      if (msg.includes('budget') || msg.includes('cheap') || msg.includes('value')) {
        filtered = filtered.sort((a, b) => parseFloat(a.price) - parseFloat(b.price));
      }

      // Luxury filters
      if (msg.includes('luxury') || msg.includes('high-end') || msg.includes('premium')) {
        if (msg.includes('ultra')) {
          filtered = filtered.filter(c => c.rating === 'Ultra Luxury');
        } else if (msg.includes('luxury')) {
          filtered = filtered.filter(c => c.rating === 'Luxury' || c.rating === 'Ultra Luxury');
        }
      }

      // Duration filters - handle specific ranges from filter buttons
      if (msg.includes('3-5 nights') || msg.includes('3-5 night')) {
        filtered = filtered.filter(c => c.nights >= 3 && c.nights <= 5);
        console.log('After 3-5 nights filter:', filtered.length);
      } else if (msg.includes('7 night')) {
        filtered = filtered.filter(c => c.nights >= 6 && c.nights <= 8);
        console.log('After 7 nights filter:', filtered.length);
      } else if (msg.includes('10-14 night')) {
        filtered = filtered.filter(c => c.nights >= 10 && c.nights <= 14);
        console.log('After 10-14 nights filter:', filtered.length);
      } else {
        // Fallback: try to parse a single number
        const nightsMatch = msg.match(/(\d+)\s*(?:night|day)/);
        if (nightsMatch) {
          const nights = parseInt(nightsMatch[1]);
          filtered = filtered.filter(c => Math.abs(c.nights - nights) <= 1);
          console.log('After ' + nights + ' nights filter:', filtered.length);
        }
      }
      if (msg.includes('week')) {
        filtered = filtered.filter(c => c.nights >= 6 && c.nights <= 8);
        console.log('After week filter:', filtered.length);
      }

      // Date/month filters
      const months = {
        'january': '01', 'february': '02', 'march': '03', 'april': '04',
        'may': '05', 'june': '06', 'july': '07', 'august': '08',
        'september': '09', 'october': '10', 'november': '11', 'december': '12',
        'spring': ['03','04','05'], 'summer': ['06','07','08'],
        'autumn': ['09','10','11'], 'fall': ['09','10','11'], 'winter': ['12','01','02'],
        'christmas': ['11','12']
      };
      for (const [keyword, monthVal] of Object.entries(months)) {
        if (msg.includes(keyword)) {
          if (Array.isArray(monthVal)) {
            filtered = filtered.filter(c => monthVal.some(m => c.start && c.start.includes(`-${m}-`)));
          } else {
            filtered = filtered.filter(c => c.start && c.start.includes(`-${monthVal}-`));
          }
          break;
        }
      }

      // Operator filters (check AFTER type filter to search within correct type)
      const operatorMap = {
        'ncl': 'Norwegian Cruise Line',
        'norwegian': 'Norwegian Cruise Line',
        'royal caribbean': 'Royal Caribbean',
        'rccl': 'Royal Caribbean',
        'msc': 'MSC Cruises',
        'carnival': 'Carnival',
        'celebrity': 'Celebrity',
        'princess': 'Princess',
        'holland': 'Holland America',
        'cunard': 'Cunard',
        'a-rosa': 'A-ROSA',
        'arosa': 'A-ROSA',
        'viking': 'Viking',
        'ama': 'AmaWaterways',
        'amawaterways': 'AmaWaterways',
        'scenic': 'Scenic',
        'uniworld': 'UNIWORLD',
        'tauck': 'Tauck'
      };
      for (const [keyword, operator] of Object.entries(operatorMap)) {
        if (msg.includes(keyword)) {
          filtered = filtered.filter(c => c.operator && c.operator.toLowerCase().includes(operator.toLowerCase()));
          break;
        }
      }

      // Return the FULL filtered list (don't slice here - let caller decide)
      return filtered;
    }

    // Get a diverse sample for the prompt (max 30)
    function getSampleCruises(filtered) {
      if (filtered.length === CRUISES.length) {
        // No filters - get diverse mix
        const sample = [];
        const operators = [...new Set(CRUISES.map(c => c.operator))];
        const perOperator = Math.ceil(30 / Math.min(operators.length, 15));
        for (const op of operators.slice(0, 15)) {
          const opCruises = CRUISES.filter(c => c.operator === op).slice(0, perOperator);
          sample.push(...opCruises);
          if (sample.length >= 30) break;
        }
        return sample.slice(0, 30);
      }
      return filtered.slice(0, 30);
    }

    function buildDynamicPrompt(userMessage) {
      // Use the already-filtered list (set in sendMessage)
      const totalMatches = filteredCruises.length;
      const sample = getSampleCruises(filteredCruises);

      // Count river vs ocean in full database
      const riverCount = CRUISES.filter(c => c.type === 'river').length;
      const oceanCount = CRUISES.filter(c => c.type === 'ocean').length;

      // Count types in ALL matches (not just sample)
      const matchRiver = filteredCruises.filter(c => c.type === 'river').length;
      const matchOcean = filteredCruises.filter(c => c.type === 'ocean').length;

      // Debug log
      console.log('Filter debug:', {
        query: userMessage,
        totalCruises: CRUISES.length,
        riverInDb: riverCount,
        oceanInDb: oceanCount,
        totalMatches: totalMatches,
        sampleSize: sample.length,
        matchRiver,
        matchOcean
      });

      const cruiseList = sample.map(c =>
        `‚Ä¢ ${c.ref}: "${c.name}" by ${c.operator} on ${c.ship} | ${c.region} | ${c.nights}N | ${c.start?.split('T')[0]} | ${c.from}‚Üí${c.to} | ${c.rating} | ¬£${c.price} | TYPE: ${c.type || 'unknown'}`
      ).join('\n');

      // Get cheapest per cruise line for the prompt
      const cheapestPerLine = getCheapestPerOperator(filteredCruises, 5);

      const cheapestList = cheapestPerLine.map(c =>
        `‚Ä¢ ${c.operator}: from ¬£${c.price} - ${c.ship} | ${c.region} | ${c.nights} nights | ${c.start?.split('T')[0]}`
      ).join('\n');

      // After 2 turns, stop asking questions and present results
      const presentResults = userTurns >= 2;

      return `You are a cruise consultant.

TODAY'S DATE: ${TODAY} - Only suggest dates from ${TODAY} onwards. NEVER mention 2025 - it's now 2026!

MATCHING CRUISES: ${totalMatches} cruises match (${matchRiver} river, ${matchOcean} ocean)

BEST PRICE PER CRUISE LINE:
${cheapestList}

${presentResults ? `
ACTION: Show best price from each cruise line AND mention the filter buttons.

RESPONSE FORMAT:
- "From ${totalMatches} matches, here's the best price per cruise line:"
- List each operator with their cheapest option (one line each)
- End with: "Use the filter buttons below to narrow by dates, duration, or budget."

Show results and point them to the filters.
` : `
ACTION: Acknowledge their search and point them to filter buttons.

RESPONSE FORMAT:
- "Great! I found ${totalMatches} [type] cruises matching your search."
- "Use the filter buttons below to narrow down by duration, dates, or budget - click as many as apply!"

Keep it to 2 sentences. Point them to the buttons. Do not list cruises yet.
`}`;
    }

    const API_URL = 'https://travel-consultant.satwinder-a59.workers.dev/';

    // Validate Claude's response against our database
    function validateResponse(responseText) {
      const issues = [];

      // Build sets of valid data for fast lookup
      const validRefs = new Set(CRUISES.map(c => c.ref));
      const validShips = new Set(CRUISES.map(c => c.ship?.toLowerCase()).filter(Boolean));
      const validOperators = new Set(CRUISES.map(c => c.operator?.toLowerCase()).filter(Boolean));
      const validCruiseNames = new Set(CRUISES.map(c => c.name?.toLowerCase()).filter(Boolean));

      // Check for ref codes in response - they should match our data
      const refPattern = /\b([A-Z]{2,}[A-Z0-9]{8,})\b/g;
      const mentionedRefs = responseText.match(refPattern) || [];
      const invalidRefs = mentionedRefs.filter(ref => !validRefs.has(ref));
      if (invalidRefs.length > 0) {
        issues.push(`Reference codes not found in database: ${invalidRefs.join(', ')}`);
      }

      // Check for ship names that look specific but don't exist
      const suspiciousShips = ['MS Botticelli', 'MS Bellini', 'SS Eternal', 'MS Roma'];
      for (const ship of suspiciousShips) {
        if (responseText.toLowerCase().includes(ship.toLowerCase()) && !validShips.has(ship.toLowerCase())) {
          issues.push(`Ship "${ship}" not found in database`);
        }
      }

      // Check if response mentions specific prices without ref codes (likely hallucinated)
      const hasPrices = /¬£\d{1,},?\d{3}/.test(responseText);
      const hasRefs = mentionedRefs.some(ref => validRefs.has(ref));
      if (hasPrices && !hasRefs && responseText.length > 500) {
        issues.push('Prices mentioned without valid cruise reference codes');
      }

      return {
        hasIssues: issues.length > 0,
        warning: issues.length > 0
          ? 'Some details may not be verified. Please confirm cruise availability before booking.'
          : '',
        details: issues
      };
    }

    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text || isLoading) return;

      // Add any text-based filters to accumulated set
      // (handles typed input as well as button clicks)
      if (text) {
        accumulatedFilters.add(text);
      }

      // Filter using ALL accumulated criteria
      const allFilters = Array.from(accumulatedFilters).join(' ');
      currentFilters.query = allFilters;
      filteredCruises = filterCruises(allFilters);
      displayCruises = [...filteredCruises]; // Cache for cards - same data Claude sees
      console.log('Filtering with accumulated:', allFilters, '‚Üí', filteredCruises.length);

      userTurns++; // Increment conversation depth

      messages.push({ role: 'user', content: text });
      input.value = '';
      isLoading = true;
      render();

      try {
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 8192,
            system: buildDynamicPrompt(text),
            messages: messages.map(m => ({ role: m.role, content: m.content }))
          })
        });

        const data = await response.json();
        console.log('API Response:', data);
        if (!response.ok || data.error) {
          const errMsg = data.error?.message || data.message || JSON.stringify(data);
          messages.push({ role: 'assistant', content: `API Error (${response.status}): ${errMsg}` });
        } else if (data.content && data.content[0]) {
          let responseText = data.content[0].text;
          const validation = validateResponse(responseText);
          if (validation.hasIssues) {
            responseText += `\n\n‚ö†Ô∏è **Notice:** ${validation.warning}`;
          }
          messages.push({ role: 'assistant', content: responseText });
        } else {
          messages.push({ role: 'assistant', content: 'Unexpected response format. Check console for details.' });
        }
      } catch (error) {
        console.error('Fetch error:', error);
        messages.push({ role: 'assistant', content: `Connection error: ${error.message}` });
      }

      isLoading = false;
      render();
    }

    // Show loading state, then load data
    render();
    loadCruiseData();
  </script>
</body>
</html>
